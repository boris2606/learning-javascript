<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Learning JS</title>
        <!-- <link rel="icon" type="image/x-icon" href="/images/favicon.ico"> тут іконка вкладки -->
    </head>
    <body>
        <h1 class="tit_text_learn"> Для ознайомлення з JavaScript оберіть розділ </h1>
        <div class="accordion accordion-flush" id="accordionFlushExample">
            <!-- Аккорд елемент Основи JS-->
            <div class="accordion-item">
              <p class="accordion-header" id="flush-headingOne">
                <button class="accordion-button collapsed btn_accord_style" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseOne" aria-expanded="false" aria-controls="flush-collapseOne">
                    <p class="header_name_item_stl">Основи JavaScript</p>
                </button>
              </p>
              <div id="flush-collapseOne" class="accordion-collapse collapse" aria-labelledby="flush-headingOne" data-bs-parent="#accordionFlushExample">
                <article class="accordion-body">
                    <div class="content_art">
                        <h3 class="sec_tit_txt_acord"> Змінні </h3>
                        <p>Всі змінні бажано вказувати в стилі "camelCase" (приклад: <code> let firstName = 'Ivan' </code>)</p>
                        <ul>
                            <li class="list_style_accord"> <code>var year = 2022</code> - Оголошення змінної з можливісттю подальшого її перезапису (метод оголошення застарівший)</li>
                            <li class="list_style_accord"> <code>const myCountry = 'Ukraine'</code> - Змінні такого типу присутні лише для читання, перезапис даної змінної недоступний (бажано використовувати якщо змінна являється незмінною)</li>
                            <li class="list_style_accord"> <code>let centry = 21 </code> - Актуальна форма оголошення змінної, доступна для перезапису</li>
                        </ul>
                    </div>
                    <div class="content_art">
                        <h3 class="sec_tit_txt_acord"> Оператори </h3>
                        <div class="pref_content">
                            <p class="preff_txt">Таблиця пріорітетності операторів знаходиться за посиланням: </p>
                            <a class="preff_link" href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Operator_Precedence" target="_black"> Перейти до таблиці</a>
                        </div>
                        <ul>
                            <li class="list_style_accord"> Оператори <code> + - * / </code> виконують дії згідно математичних обчислень </li>
                            <li class="list_style_accord"> При використанні оператора <code>++</code> до змінної <code>(прикад: year++)</code> буде виконано інкрементування, тобто збільшення значення змінної після зчитування <code>+1</code>, якщо використати перед змінною <code>(прикад: ++year)</code> буде виконано спочатку збільшення на <code>+1</code> потім зчитування</li>
                            <li class="list_style_accord"> При використанні оператора <code>--</code> до змінної <code>(прикад: year--)</code> буде виконано декрементування, тобто зменшення значення змінної після зчитування <code>-1</code>, якщо використати перед змінною <code>(прикад: --year)</code> буде виконано спочатку зменшення на <code>-1</code> потім зчитування</li>
                            <li class="list_style_accord"> При перепризначення однієї змінної використовуючи значення іншої змінної <code>(приклад змінних: let a = 10, let c = 15, можна написати c = c + a, після чого c = 25)</code> , даний запис можна використовувати в спрощеній формі <code>(приклад: let a = 10, let c = 15, c += a)</code> таким чином можна використовувати інші оператори <code> + - * / </code></li>
                        </ul>
                    </div>
                    <div class="oper_wrapp_list content_art">
                        <div>
                            <p class="oper_tit"> Оператори умови: </p>
                            <ul>
                                <li class="list_style_accord"><code> if (){} else </code></li>
                                <li class="list_style_accord"><code> if (){} else if (){} else {}</code></li>
                                <li> Приклад : <br> <code> let currYear = 2022 <br> if (currYear == 2022){ <br> alert('Так, рік вірний') <br> } else { <br> alert('Рік не відповідає поточному') <br> } </code></li>
                                <li> Якщо в умові виокристовується boolean <br> тип, то даний запис можна скоротити,<br> використовуючи тернарний вираз, приклад: <br><code> let isReady = false <br> isReady ? alert('Готово!') : alert('Не готово') </code></li>
                            </ul>
                        </div>
                        <div>
                            <p class="oper_tit">Оператори порівняння: </p>
                            <ul>
                                <li><code> > </code> суворо більше </li>
                                <li><code> < </code> суворо менше </li>
                                <li><code> >= </code> більше або дорівнює </li>
                                <li><code> <= </code> меньше або дорівнює </li>
                                <li><code> == </code> перевірка рівності без звірки типу змінної </li>
                                <li><code> === </code> сувора перевірка враховуючи тип змінної </li>
                            </ul>
                        </div>
                    </div>
                    <div class="content_art">
                        <p class="oper_tit"> Оператори логіки: </p>
                        <ul>
                            <p> Логічне "І" <code>( && )</code> Виявляє операнди зліва направо, повертаючи відразу значення першого попавшогося "Хибноподібного" операнду, якщо всі значення "Правдоподібні" вертає значення останнього операнду.</p>
                            <li class="list_style_accord"><code> && </code> Логічне "І" - <code>(приклад: exz1 && exz2)</code> В результаті, якщо оба значення <code>true</code> тоді отримуємо результат <code>true</code>, якщо хоч одне значення <code>false</code>, то ми отримуємо <code>false</code></b></li>
                            <li class="list_style_accord"><code> || </code> Логічне "АБО" -<code>(приклад: exz1 || exz2)</code> при використанні з величинами <code>boolean</code> опертору <code> || </code> поверне значення <code>true</code> якщо хоч один зних рівний <code>true</code> в іншому випадку поверне <code>false</code></li>
                            <li class="list_style_accord"><code> ! </code> Логічне "НІ" - <code>(приклад: !exz)</code> Повертає значення <code>false</code> якщо <code>exz</code> можна привести в <code>true</code> в іншому випадку повертає значення <code>true</code></li>
                        </ul>
                    </div>
                    <div class="content_art">
                        <h3 class="sec_tit_txt_acord"> Типи даних </h3>
                        <ul>
                            <p>Для перевірки типу даних змінної необхідно використовувати наступний запис <code>( приклад: console.log(typeof змінна); )</code>або <code> typeof змінна </code> в консолі</p>
                            <li class="list_style_accord"><code>boolean</code> може приймати значення <code>true / false</code></li>
                            <li class="list_style_accord"><code>string</code> текстове значення </li>
                            <li class="list_style_accord"><code>number</code> числове значення </li>
                            <li class="list_style_accord"><code>undefined</code> невизначене значення</li>
                            <li class="list_style_accord"><code>null</code> відсутнє значення </li>
                        </ul>
                    </div>
                    <div class="content_art">
                        <h3 class="sec_tit_txt_acord"> Функції </h3>
                        <ul>
                            <p>Значення команд:</p>
                            <li class="list_style_accord"><code>return</code> - повернення значення з функції </li>
                        </ul>
                        <p>Приклад базової функції:<br> <code>function calculateAge(year){ <br> return 2022 - year<br> } <br> console.log(calculateAge(1992))</code></p>
                        <p>Присутня можливість використання функції в середині функції, приклад: <br><code>let myAge = 1992 <code class="comment_code"> // Оголошення змінної року народження</code><br>let myName = "Борис" <code class="comment_code"> // Оголошення змінної ім'я</code><br><br>function calculateAge(year){<code class='comment_code'> // Функція обрахунку різниці років</code><br>return 2022 - year<br>}<br>function logInfoPerson(name,year) {<code class="comment_code">// Функція виводу ім'я та року народження</code><br>   let age = calculateAge(year)<br>if (age > 0){ <code class="comment_code"> // Перевірка року, чи він більше 0</code><br>console.log('Імя людини:' + name + ' Вік людини ' + ' ' + age);<br>    } else {<br>        alert('введіть коректний вік')<br>    }<br>}<br>logInfoPerson(myName,myAge); <code class="comment_code"> // Виклик функції з заданими параметрами myAge,myName</code><br></code></p>
                    </div>
                    <div class="content_art">
                        <h3 class="sec_tit_txt_acord"> Масиви </h3>
                        <p>Приклад запису масивів:</p>
                        <ul>
                            <li class="list_style_accord"><code>let cars = ['audi','bmw','opel','honda'];</code><code class="comment_code">// Краще використовувати даний шлях запису</code></li>
                            <li class="list_style_accord"><code>let cars = new Array('audi','bmw','opel','honda');</code><code class="comment_code">// Можливі проблеми з таким видом запису</code></li>
                        </ul>
                        <p>Присутня змога звернення до конкретного елементу масиву за індексом, приклад:<br><code>let cars = ['audi','bmw','opel','honda']; <br>console.log(cars[2]) <code class="comment_code">// В даному випадку виведе елемент opel, тобто 3 елемент. Всі елементи починаються з індексу [0] - це перший елемент </code></code></p>
                        <p>Присутня змога зміни конкретного елементу масиву за індексом, приклад:<br><code>cars[0] = 'toyota' <br>console.log(cars) <code class="comment_code">// В даному випадку елемент toyota стане першим елементом масиву, замінивши попередній. Тобто cars = ['toyota','bmw','opel','honda'] </code></code></p>
                        <p>Команди для роботи з масивами:</p>
                        <p class="list_style_accord">Масив: <code>let cars = ['audi','bmw','opel','honda']</code></p>
                        <ul>
                            <li class="list_style_accord"><code>console.log(cars)</code> Перегляд масиву</li>
                            <li class="list_style_accord"><code>console.log(cars[0])</code> Звернення до певного елементу масиву</li>
                            <li class="list_style_accord"><code>console.log(cars.lenght)</code> Перегляд довжини масиву, кількість елементів</li>
                            <li class="list_style_accord"><code>cars[cars.lenght] = 'Kia'</code> Додавання елементу в кінець масиву</li>
                        </ul>
                    </div>
                    <div class="content_art">
                        <h3 class="sec_tit_txt_acord"> Цикли </h3>
                        <p>Приклади використання циклу з масивом: <br> Присутній масив <code>let cars = ['Audi','BMW','Opel','Honda']</code></p>
                        <ul>
                            <li class="list_style_accord"><code>for (let i = 0; i < cars.length; i++){ <code class="comment_code"> // Застарілий спосіб</code><br>console.log(cars[i]);<br>};</code></li>
                            <li class="list_style_accord"><code>for (let car of cars) {<code class="comment_code"> // Новий спосіб, де car змінна являється елементом масиву cars. Такий метод називається "forof" </code><br>console.log(car);<br>}</code></li>
                        </ul>
                    </div>
                    <div class="content_art">
                        <h3 class="sec_tit_txt_acord"> Об'єкти </h3>
                        <p>Приклад об'єкту: </p>
                        <ul>
                            <li class="list_style_accord"><code>let person = {<br>firstName: 'Boris',<br>secondName: 'Shagiev',<br>year: 1992<br>};</code></li>
                        </ul>
                        <p>Як ключ об'єкту може виступати масив, приклад:</p>
                        <ul>
                            <li class="list_style_accord"><code>let person = {<br>firstName: 'Boris',<br>secondName: 'Shagiev',<br>year: 1992,<br>languages: ['Uk','Ru','En'],<br>};</code></li>
                        </ul>
                        <p>Також можна в якості ключа використовувати boolean значення:</p>
                        <ul>
                            <li class="list_style_accord"><code>let person = {<br>firstName: 'Boris',<br>secondName: 'Shagiev',<br>year: 1992,<br>languages: ['Uk','Ru','En'],<br>hasWife: true,<br>};</code></li>
                        </ul>
                        <p>Для звернення до певного ключа об'єкту необхідно використовувати наступний вид запису: <code>console.log(person.firstName)</code> в даному випадку буде отримано значення ключа firstName об'єкту person </p>
                        <p>В об'єкті є змога використовувати функцію: <br><code>let person = {<br> firstName: 'Boris',<br> someFunc: function(){<br> console.log(someFunc)<br>} </code></p>
                        <p>Методи звернення до об'єкту:</p>
                        <ul>
                            <li class="list_style_accord"><code> console.log(person.firstName)</code></li>
                            <li class="list_style_accord"><code> console.log(person['firstName'])</code></li>
                            <li class="list_style_accord"><code> let key = 'year' <code class="comment_code"> // При призначенні змінній ключа об'єкту, ключ обов'язково повинен бути написаний текстовим типом в скобках :' '</code> <br> console.log(person[key])</code><code class="comment_code">// Можна призначити змінну по назві ключа, та зробити звернення по цій змінні до об'єкту. В результаті чого, буде отримано значення ключа year об'єкту person, що дорівнює 1992</code></li>
                        </ul>
                        <p>Присутня змога зміни значення ключа, приклад: <br> <code>person.firstName = 'Sergey'</code> після чого ключ firstName об'єкту person буде змінено на Sergey</p>
                        <p>Присутня змога додавання ключів в об'єкт, приклад: <br> <code>person.isProgrammer = true,</code> після чого буде добавлено ключ isProgrammer в об'єкт person. Головне щоб даного ключа не було в об'єкті, якщо він буде присутній, то значення просто зміниться</p>
                    </div>
                </article>
              </div>
            </div>
            <!-- Аккорд елемент Числа + BigInt -->
            <div class="accordion-item">
                <p class="accordion-header" id="flush-headingTwo">
                  <button class="accordion-button collapsed btn_accord_style" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseTwo" aria-expanded="false" aria-controls="flush-collapseTwo">
                    <p class="header_name_item_stl">Числа + <span class="fix_upper"> BigInt </span></p>
                  </button>
                </p>
                <div id="flush-collapseTwo" class="accordion-collapse collapse" aria-labelledby="flush-headingTwo" data-bs-parent="#accordionFlushExample">
                  <article class="accordion-body">
                    <div class="content_art">
                        <p class="sec_tit_txt_acord"> Числа - Number </p>
                        <p>Числа можуть бути двох типів:</p>
                        <ul>
                            <li class="list_style_accord"> <code>let numInteger  = 42</code> - integer число(ціле)</li>
                            <li class="list_style_accord"> <code>let numFloat = 42.35</code> - float число(не ціле число)</li>
                            <li class="list_style_accord"> <code>let numPow = 10e3 </code> - pow число (в даному випадку 10 в 3 степені, по результату дорівню 10000)</li>
                            <li class="list_style_accord"> <code>let notNum  = NaN</code> - Not A Number - при використанні typeof рахується числом</li>
                        </ul>
                        <p>Для приведення числа в <code>NaN</code> необхідно виконати ділення на <code>undefined</code> приклад: <br> <code>let num = 2 / undefined</code></p>
                        <p>Для перевірки чи число являється <code>NaN</code> можна наступним чином, приклад :<br> <code>let weird = 2 / undefined<br>console.log(isNaN(weird))</code><code class="comment_code">// В даному випадку результатом буде true, так як результат ділення на undefined буде NaN</code></p>
                        <p>Для приведення рядка в число з integer(цілим) значенням необхідно використати команду <code>parseInt</code> приклад:<br> <code>let strNumInteger = '42'<br>let num = parseInt(strNumInteger)</code> після чого num буде цілим числом </p>
                        <p>Для приведення рядка в число з float(число з сотими 42.42) значенням необхідно використати команду <code>parseFloat</code> приклад:<br> <code> let strNumFloat = '42.42'<br> let numFloat = parseFloat(strNumFloat) </code> </p>
                        <p>Методи приведення string змінної в число:</p>
                        <ul>
                            <li class="list_style_accord"><code>let strNumFloat = '42' <br> let numFloat = pareseFloat(strNumFloat)</code> <code class="comment_code"> // Для чисел з сотими приклад: 42.42</code> </li>
                            <li class="list_style_accord"><code>let strNumInteger = '42' <br> let numInteger = pareseInt(strNumInteger)</code> </li>
                            <li class="list_style_accord"><code>let strNumInteger = '42' <br> let numInteger = Number(strNumInteger)</code><code class="comment_code">// Доступне використання з float числами , приклад 42.42</code></li>
                            <li class="list_style_accord"><code>let strNumInteger = '42' <br> let numInteger = +strNumInteger</code><code class="comment_code">// Доступне використання з float числами , приклад 42.42</code></li>
                        </ul>
                        <p>Для обмеження кількості знаків в числі після "." необхідно використати команду <code>toFixed(число, скільки потрібно після .)</code> але після використання його число буде з типом <code>string</code>. для коректного використання неоюхідно перевести результат в <code>number</code> необхідно використати команду <code>parseInt / parseFloat або оператор '+'(відповідно чи число integer чи float)</code>, приклад: <br> <code>let a = 0.4 <br> let b = 0.2 <br> let sumStr = a + b <br> let sumNumber = +sumStr.toFixed(3) </code> <code class="comment_code">// В даному випадку приводимо змінну в number за допомогою "+", та вказуємо що після "." необхідно відображати лише 3 знаки за допомогою toFixed(3)</code></p>
                    </div>
                    <div class="content_art">
                        <p class="sec_tit_txt_acord"> Тип даних - <span class="fix_upper"> BigInt </span></p>
                        <p>BigInt - тип даних, який використовується для роботи з числами більшими за MAX_SAFE_INTEGER. <code> console.log(Number.MAX_SAFE_INTEGER) буде дорівнювати 9007199254740991</code> </p>
                        <p>Для приведення числа в тип BigInt необхідно в кінці великого числа дописати <code>n</code>, приклад: <br><code> console.log(99999999999999999999999999999n)</code></p>
                        <p>BigInt має змогу оперувати лише з значеннями такого самого типу, та працює лише з значенняти integer. З числом в якого є десяткові значення НЕ ПРАЦЮЄ!</p>
                    </div>
                    <div class="content_art">
                        <p class="sec_tit_txt_acord"> Об'єк - Math</p>
                        <p>Об'єкт <code>Math</code> дозволяє працювати з різними математичними операціями </p>
                        <p>Константи даного об'єкту:</p>
                        <ul>
                            <li class="list_style_accord"><code>Math.E</code> - експонента, приклад: <code>console.log(Math.E)</code> яка рівна 2.718281828459045 </li>
                            <li class="list_style_accord"><code>Math.PI</code> - число ПІ, приклад: <code>console.log(Math.PI)</code>  яка рівна 3.141592653589793</li>
                        </ul>
                        <p>Методи об'єкту <code>Math</code>:</p>
                        <ul>
                            <li class="list_style_accord"><code>console.log(Math.sqrt(25))</code> - Квадратний корінь з числа</li>
                            <li class="list_style_accord"><code>console.log(Math.pow(5,2))</code> - Піднесення 5 до степіні 2</li>
                            <li class="list_style_accord"><code>console.log(Math.abs(-42))</code> - Модуль числа -42 </li>
                            <li class="list_style_accord"><code>console.log(Math.max(3,12,41,42,18))</code> - Виявлення максимального числа зі списку які передаємо, в цьому прикладі 42  </li>
                            <li class="list_style_accord"><code>console.log(Math.min(3,12,41,42,18))</code> - Виявлення мінімального числа зі списку які передаємо, в цьому прикладі 3 </li>
                            <li class="list_style_accord"><code>console.log(Math.floor(4.9))</code> - Округлення до меншого , в результаті прикладу буде 4</li>
                            <li class="list_style_accord"><code>console.log(Math.ceil(4.3))</code> - Округлення до більшого , в результаті буде 5</li>
                            <li class="list_style_accord"><code>console.log(Math.round(4.6))</code> - Округлення до найближчого цілого, в даному прикладі 5</li>
                            <li class="list_style_accord"><code>console.log(Math.trunc(1.634))</code> - Відкидає десяті, в результаті отримаємо в даному прикладі 1</li>
                            <li class="list_style_accord"><code>console.log(Math.random())</code> - Значення не передається, автоматично генерує випадкове число</li>
                        </ul>
                        <p>Приклад функції , яка буде генерувати автоматично та повертати випадкове число в діапазоні двух цілих чисел які буде вказано: <br><code> function randomNumber (min, max){<br>return  Math.round(Math.random() * (max - min +1) + min)<br>}<br>let num = randomNumber(1,100)<br>console.log(num)</code></p>
                    </div>


                  </article>
                </div>
                
            </div>
            <!-- Рядки -->
            <div class="accordion-item">
                <p class="accordion-header" id="flush-headingThree">
                  <button class="accordion-button collapsed btn_accord_style" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseThree" aria-expanded="false" aria-controls="flush-collapseThree">
                    <p class="header_name_item_stl">Рядки - string</p>
                  </button>
                </p>
                <div id="flush-collapseThree" class="accordion-collapse collapse" aria-labelledby="flush-headingThree" data-bs-parent="#accordionFlushExample">
                  <article class="accordion-body">
                    <div class="content_art">
                        <p class="sec_tit_txt_acord"> Рядки </p>
                        <p>В рядку(string) можна використовувати змінні декількома шляхами приклад: <code>let name = 'Борис' <br> let age = 30</code></p>
                        <ul>
                            <li class="list_style_accord"> <code>let someText = 'Привіт, мене звати ' + name + ' мій вік ' + age </code><code class="comment_code">// В даному випадку легко запутатись</code> </li>
                            <li class="list_style_accord"> <code>let someText = `Привіт, мене звати ${name} мій вік ${age}`</code><code class="comment_code">// Це варіант запису являється простішим для сприймання і в <code>${..}</code> можна передавати не лише змінні а і функції, і тернарні вирази. Обов'язковою умовою є використання кавичок з нахилом<code> ` ` </code></code></li>
                            <li class="list_style_accord"> <code>let someText = `Привіт, мене звати ${name} мій вік ${age} ${age > 18 ? alert('Ти повнолітній') : alert('Ще молодий')}`</code><code class="comment_code">// Приклад використання тернарного виразу в рядку</code></li>
                        </ul>
                    </div>
                    <div class="content_art">
                        <p class="sec_tit_txt_acord"> Методи роботи з рядками </p>
                        <p>Приклад методів для роботи з рядками.Для прикладу присутня змінна <code> let myName = 'Борис' </code></p>
                        <ul>
                            <li class="list_style_accord"> <code>console.log(myName.lenght)</code> Перевірка кількості символів в змінній</li>
                            <li class="list_style_accord"> <code>console.log(myName.toUpperCase())</code> Приведення всіх символів до верхнього регістру</li>
                            <li class="list_style_accord"> <code>console.log(myName.toLowerCase())</code> Приведення всіх символів до нижнього регістру</li>
                            <li class="list_style_accord"> <code>console.log(myName.charAt(2))</code> Перевірка який символ знаходиться на індексі 2, перший символ починається з 0 індексу</li>
                            <li class="list_style_accord"> <code>console.log(myName.indexOf('ис'))</code> Перевірка чи в строці є підстрока з символами "ис", буде показано з якого индексу починається підстрока. Якщо підстрока відсутня в змінній то буде повернуто значення -1</li>
                            <li class="list_style_accord"> <code>console.log(myName.startsWith('Бо'))</code> Перевірка чи рядок починається з "Бо". вертає значення true/false. Метод чутливий до регістру "Бо" "бо"</li>
                            <li class="list_style_accord"> <code>console.log(myName.endsWith('ис'))</code> Перевірка чи рядок закінчується на "ис". вкртає значення true/false. </li>
                            <li class="list_style_accord"> <code>console.log(myName.repeat(3))</code> Вказуємо скільки разів повторити рядок, в даному випадку 3</li>
                            <li class="list_style_accord"> <code>console.log(myName.trim())</code> Видаляє всі пробіли в змінній</li>
                            <li class="list_style_accord"> <code>console.log(myName.trimLeft())</code> Видалення пробілів зліва</li>
                            <li class="list_style_accord"> <code>console.log(myName.trimRight())</code> Видалення пробілів справа</li>
                        </ul>
                    </div>

                  </article>
                </div>
            </div>
            <!-- Функції -->
            <div class="accordion-item">
                <p class="accordion-header" id="flush-headingFour">
                  <button class="accordion-button collapsed btn_accord_style" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseFour" aria-expanded="false" aria-controls="flush-collapseFour">
                    <p class="header_name_item_stl">Функції</p>
                  </button>
                </p>
                <div id="flush-collapseFour" class="accordion-collapse collapse" aria-labelledby="flush-headingFour" data-bs-parent="#accordionFlushExample">
                  <article class="accordion-body">
                    <div class="content_art">
                        <p class="sec_tit_txt_acord"> Типи функцій </p>
                        <p> Присутні 2 типи функцій:</p>
                        <ul>
                            <li><code> Function Declaration</code> - Може бути викликана будь-де </li>
                            <li><code> Function Expression</code> - Може бути викликана лише після її створення</li>
                        </ul>
                        <ul>
                            <li class="list_style_accord"> <code>function person(name){ <code class="comment_code">// Даний тип має назву Function Declaration</code> <br> console.log('Привіт - ', name)<br>}<br>person('Борис')</code></li>
                            <li class="list_style_accord"> <code>let person = function person(name){<code class="comment_code">// Даний тип має назву Function Expression , тобто функція яка призначена змінній</code> <br>console.log('Привіт - ', name)<br>}<br>person('Борис')</code></li>
                        </ul>
                    </div>
                    <div class="content_art">
                        <p class="sec_tit_txt_acord"> Анонімні функції </p>
                        <p> Анонімними функції - це функції які без назви</p>
                        <p>Приклад: <br> <code>setInterval( function { <code class="comment_code"> // setInterval - метод JS який дозволяє виконати функцію через певний час</code> <br> console.log('Hellow world')<br> },1000) <code class="comment_code">// час через який запрацює функція</code>  </code></p>
                    </div>
                    <div class="content_art">
                        <p class="sec_tit_txt_acord"> Стрілочні функції </p>
                        <p>Приклад стрілочної функції:</p>
                        <ul>
                            <li class="list_style_accord"><code>function person(name){ <code class="comment_code">// Приклад звичайної функції</code><br> console.log('Привіт - ', name) <br>}<br> </code> </li>
                            <li class="list_style_accord"><code>let arrow = (name) => { <code class="comment_code">// Приклад стрілочної функції, де name параметр</code><br> console.log('Привіт - ',name)<br>}<br></code></li>
                            <li class="list_style_accord"><code>let arrow = name => console.log('Привіт - ',name)<br></code> <code class="comment_code">// Скорочений приклад стрілочної функції, де name параметр, його можна не брати в дужки так як параметр тільки 1, також у фігурні дужки не берем умову, у зв'язку з тим що умова у вигляді однієї стрічки</code></li>
                        </ul>
                        <p>Усі ці функції рівнозначні, мають лише різний запис. Якщо до функції не передаються параметри, дужки писати потрібно обов'язково</p>
                    </div>
                    <div class="content_art">
                        <p class="sec_tit_txt_acord"> Параметри за замовчуванням </p>
                        <p>Приклад функції з параметрами за замовчуванням:</p>
                        <ul>
                            <li class="list_style_accord"><code> let somFunc = (a = 1,b = 1) => a + b <br> console.log(someFunc(40,51))</code> <code class="comment_code"> // В Даному випадку присутня стрілочна функція, значення параметрів якої за замовчуванням 1, але якщо при викликук функції буде вказано інші параметри, для прикладу 40 та 51 то вони будуть пріорітетом для прийняття як параметр</code></li>
                            <li class="list_style_accord"><code> function sumAll(...all){<br>console.log(all)<br>}<br> sumAll(1,2,3,4,5,6,7)</code> <code class="comment_code"> // Для прийняття безлічі значень використовується "...all" - оператор rest. В даному випадку всі значення які будуть передані вони будуть сформовані в масив</code></li>
                            <li class="list_style_accord"><code> function sumAll(...all){<code class="comment_code">// Приклад функції яка додає усі прийняті параметри, вони можуть бути збільшені або зменшені</code> <br>let result = 0<br>for (let num of all){<br>result += num<br>}<br>return result<br>}<br>let sumRes = sumAll(1,2,3,4,5,6,7)<br>console.log(sumRes)</code><br> В даному випадку буде результатом загальне значення параметрів які були передані в sumAll</li>
                        </ul>
                    </div>
                    <div class="content_art">
                        <p class="sec_tit_txt_acord"> Замикання </p>
                        <p> Замиканням можна назвати явище коли ми з одниєї функції вертаємо іншу функцію, після буде виконано збереження певного контексту</p>
                        <ul>
                            <li class="list_style_accrod"><code>function createMember(name){<br>&nbsp&nbsp return function(lastName){<br>&nbsp&nbsp&nbsp console.log(name + ' ' + lastName)<br>&nbsp&nbsp}<br>}<br><br> let logWithLastName = createMember('Борис')<br>console.log(logWithLastName('Іванов')) </code></li>
                        </ul>
                        <p>В даному випадку logWithLastName ми вже присвоїли параметр name функції createMember. Тобто вже напряму при виклику функції через змінну logWithLastName можна вказати параметр lastName</p>
                    </div>
                  </article>
                </div>
            </div>
            <!-- Масиви -->
            <div class="accordion-item">
                <p class="accordion-header" id="flush-headingFive">
                  <button class="accordion-button collapsed btn_accord_style" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseFive" aria-expanded="false" aria-controls="flush-collapseFive">
                    <p class="header_name_item_stl">Масиви</p>
                  </button>
                </p>
                <div id="flush-collapseFive" class="accordion-collapse collapse" aria-labelledby="flush-headingFive" data-bs-parent="#accordionFlushExample">
                  <article class="accordion-body">
                    <div class="content_art">
                        <p class="sec_tit_txt_acord"> Основи </p>
                        <p>Масиви - певна структура даних яка містить в собі певі елементи. Приклад масиву: <code>let cars = ['BMW','Honda','Mazda',3,6,7]</code> Всі елементи знаходяться під певним індексом та перший елемент є з індексом 0</p>
                        <p>Методи роботи з масивами: </p>
                        <ul>
                            <li class="list_style_accord"> <code>cars.push('Opel')</code> - Додавання елементу в кінець масиву</li>
                            <li class="list_style_accord"> <code>cars.unshift('Kia')</code> - Додавання елементу в початок масиву</li>
                            <li class="list_style_accord"> <code>cars.shift()</code> - Видалення елементу з початку масива, та повертає значення даного елементу (Тобто при видаленні елементу можна його призначити до змінної)</li>
                            <li class="list_style_accord"> <code>cars.pop()</code> - Видалення елементу з кінця масива, та повертає значення даного елементу (Тобто при видаленні елементу можна його призначити до змінної)</li>
                            <li class="list_style_accord"> <code>cars.reverse()</code> - Перевертає масив</li>
                            <li class="list_style_accord"> <code>text.split('')</code> - Приведення стрічки <code>(Приклад: let text = 'Привіт, мене звати Борис'</code> в масив, де <code>split(' ')</code> - в лапках необхідно вказати символ по яким буде розділено на елементи масиву, якщо це буде пробіл, то кожен елемент по наявному пробілу буде розбито. Якщо буде пусто то кожен символ буде як елемент масиву </li>
                            <li class="list_style_accord"> <code>cars.indexOf('BMW')</code> - отримання индексу елементу масиву</i>
                            <li class="list_style_accord"> <code>cars.includes('BMW')</code> - Перевірка находження елементу в масиві. Вертає значення <code>true/false</code></i>
                            <li class="list_style_accord"> <code>people.findIndex(function(){})</code> - Пошук індексу об'єкту в масиві. Працює лише з використанням функції, приклад використаня в "Приклади"</li>
                            <li class="list_style_accord"> <code>people.find(function(){})</code> - Пошук об'єкту в масиві. Працює лише з використанням функції, приклад використаня в "Приклади" </i>
                        </ul>
                        <p>Приклади:</p>
                        <ul>
                            <li class="list_style_accord"><code>let cars = ['Honda','BMW','Nissan']<br>let newCar = cars.indexOf('BMW')<br>cars[newCar] = 'Opel'<br></code>Пошук елементу в масиві, та заміна його на певний елемент. Чудово працює з примітивними типами даних</li>
                            <li class="list_style_accord"><code>let people = [<code class="comment_code"> // ПРИКЛАД №1 - ПОШУК ІНДЕКСУ ОБ'ЄКТУ В МАСИВІ, ВИКОРИСТОВУЮЧИ МЕТОД "findIndex"</code> <br>&nbsp{name: 'Elena', budget: 3900},<br>&nbsp{name: 'Boris', budget: 4600},<br>&nbsp{name: 'Victoria', budget: 2800}<br>]<br><br>let index = people.findIndex(function(person){<br>&nbsp return person.budget === 4600<br>})<br>console.log(people[index])</code><br> В даному прикладі присутній масив з об'єктами <code>people</code>. Для пошуку індексу об'єкту використовується метод <code>findIndex()</code> з функцією в середині <code>( так як даний метод виконує дію циклу )</code>, яка приймає значення в собі <code>person</code>. Результатом функції є повернення значення з неї особи , яка має ключ об'єкту <code>budget</code>, що дорівнює вказаному </li>
                            <li class="list_style_accord"><code>let people = [<code class="comment_code"> // ПРИКЛАД №2 - ПОШУК ОБ'ЄКТУ В МАСИВІ ВИКОРИСТОВУЮЧИ МЕТОД "find"</code> <br>&nbsp{name: 'Elena', budget: 3900},<br>&nbsp{name: 'Boris', budget: 4600},<br>&nbsp{name: 'Victoria', budget: 2800}<br>]<br><br>let person = people.find(function(person){<br>&nbsp return person.budget === 4600<br>})<br>console.log(people)</code><br>Якщо необхідно знайти людину з масиву (або об'єкт з масиву напряму), можна використати метод <code>find()</code> з функцією в середині. Даний метод виконує дію циклу,яка приймає значення в собі <code>person</code>. Результатом функції є повернення значення з неї особи , яка має ключ об'єкту <code>budget</code>, що дорівнює вказаному  </li>
                            <li class="list_style_accord"><code>let people = people.find( person => person.budget === 3900) <br> console.log(people)</code> <br> Приклад скороченого запису функції <code>ПРИКЛАДУ №2</code> використовуючи стрілочну функцію</li>
                        </ul>
                    </div>
                    <div class="content_art">
                        <p class="sec_tit_txt_acord"> Методи високого порядку </p>
                        <p> Для прикладу буде використовуватись наступний масив :<code> let cars = ['BMW','Honda','Mazda']</code> </p>
                        <p> Методи високого порядку</p>
                        <ul>
                            <li class="list_style_accord"><code>cars.map(function(){})</code> Приймає в себе функцію. Метод <code>map()</code> перетворює дані масиву. ЗАВЖДИ ПРИЙМАЄ В СЕБЕ НОВИЙ МАСИВ!!! <br> Приклад, використовуючи стрілочну функцію: <br> <code>let upperCaseCars = cars.map(car => car.toUpperCase())</code> </li>
                            <li class="list_style_accord"><code>let numbers = [1,2,3,5,10,15]<br> let filtredNumbers = numbers.filter( num => num > 5 )</code><br>Приклад використовуючи стрілочну функцію: <br> Фільтрування масиву, вибираючи всі числа з нього які БІЛЬШе 5, та повертає новий масив значень лише тих які більше 5 </li>
                            <li class="list_style_accord"><code>people.reduce(function (){}, 2000)</code>Поєднання всіх значень масиву в одне. Приймає в себе 2 значення: 1 - функція, 2 - початкове значення</li>
                        </ul>
                        <p>Приклад використання методу <code> reduce( function(){}, value ) </code>використовуючи стрілочну функцію:</p>
                        <p><code> let people = [<br>&nbsp{name: 'Elena', budget: 3900},<br>&nbsp{name: 'Boris', budget: 4600},<br>&nbsp{name: 'Victoria', budget: 2800} <br>]<br><br>let allBudget = people.filter(person => person.budget > 3000).reduce((acc, person) => { <br>&nbsp acc += person.bunget<br>&nbsp return acc <br>} , 0)</code></p>
                        <p>В даному прикладі у нас є масив з людьми. Необхідно знайти всіх людей з бюджетом більше 3000, та додати ці бюджети. Для виконнання даної задачі буде використовуватись 2 методи <code> filter(function (){})</code> (за допомогою якого буде відфільтровано людей у яких бюджет більший за 3000) та <code>reduce(function(acc , person){}, value)</code>, де <code>value</code> це початкове значення (Для поєднання відфільтрованих значень масиву) В методі <code>reduce</code> в ролі <code>acc</code> виступає "акумулятор" </p>
                    </div>
                  </article>
                </div>
            </div> 
            <!-- Об'єкти -->
            <div class="accordion-item">
                <h2 class="accordion-header" id="flush-headingSix">
                  <button class="accordion-button collapsed btn_accord_style" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseSix" aria-expanded="false" aria-controls="flush-collapseSix">
                    <p class="header_name_item_stl">Об'єкти</p>
                  </button>
                </h2>
                <div id="flush-collapseSix" class="accordion-collapse collapse" aria-labelledby="flush-headingSix" data-bs-parent="#accordionFlushExample">
                  <article class="accordion-body">
                    <div class="content_art">
                        <p class="sec_tit_txt_acord"> Основи </p>
                        <p>Приклад об'єкту:</p>
                        <p><code>
                            let person = {<br>&nbsp
                                name: 'Boris',<br>&nbsp
                                age: 29,<br>&nbsp
                                isProgrammer: true,<br>&nbsp
                                languages:['UK','EN','RU'],<br>&nbsp
                                greet: function(){<br>&nbsp&nbsp
                                    console.log(`Hellow mr.${person.name}`);<br>&nbsp
                                },<br>
                            }<br>
                            </code>
                        </p>
                        <p>Функцію, як ключ об'єкту можна писати скорочено, приклад:</p>
                        <p><code>
                            greet(){<br>&nbsp&nbsp
                                console.log(`Hellow mr.${person.name}`);<br>&nbsp
                            },<br>
                        </code></p>
                        <p>Методи які використовуються для звернення до ключів об'єкту:</p>
                        <ul>
                            <li class="list_style_accord"><code>person.name</code> - Звернення до ключа name</li>
                            <li class="list_style_accord"><code>person.['age']</code> - Звернення до ключа age</li>
                            <li class="list_style_accord"><code>person.greet()</code> - Виклик функції з об'єкту</li>
                            <li class="list_style_accord"><code>delete person.age</code> - Видалення ключа age з об'єкту</li>
                        </ul>
                    </div>
                    <div class="content_art">
                        <p class="sec_tit_txt_acord"> Новий синтаксис для роботи з о'єктами </p>
                        <p>Приклад деструктуризації:</p>
                        <p><code> let name = person.name <br> let age = person.age</code></p>
                        <p>Для уникання дублювання, можна використати наступний запис, який створить змінні з об'єкту person <br><code>let {name , age} = person</code> <br> Якщо назва змінної буде відрізнятись від назви ключа, то можна це зробити наступним чином:<br> <code> let {name: personName, age: personAge} = person</code></p>
                    </div>
                    <div class="content_art">
                        <p class="sec_tit_txt_acord"> Реалізація ітерації об'єкту</p>
                        <p>Присутні декілька можливостей зробити ітерацію об'єкту:</p>
                        <ul>
                            <li class="list_style_accord"><code>
                                for (let ket in person){<br>

                                }
                            </code> Можливість використання<code> forIn</code> при чому <code>key</code> буде приймати в себе НАЗВУ КЛЮЧА. <br> Для звернення до значення ключа необхідно використовувати наступний запис <code>person[key]</code>. Цикл forIn є небезпечним, так як він має доступ не лише до ключів об'єкту, він також може мати доступ до його <code>Прототипу</code></li>
                        </ul>
                        <p>Для уникання проблем з прототипом об'єкту при проходжені циклом <code>foreIn</code> необхідно в нього включати наступну перевірку: </p>
                        <p><code>
                            for (let key in person){<br>&nbsp;
                                if (person.hasOwnProperty(key)){<br>&nbsp&nbsp
                                    // Тут вже пишемо необхідний нам код<br>&nbsp;
                                }<br>
                            }<br>
                        </code></p>
                        <p>Більш безпечний спосіб проходження по об'єкту є наступний:</p>
                        <p><code>
                            let keys = Object.keys(person) <code class="comment_code"> // Метод Object.keys, отримує ключі об'єкту у вигляді масиву</code><br>
                            keys.forEach( (key) => { <code class="comment_code"> // Цикл forEach робить ітерацію по масиву де key це callback функція. key приймає в себе кожен ітеруємий елемент </code><br>&nbsp
                                Тут пишем необхідний код <br>
                            })<br>
                        </code></p>
                        <p>Так як Object.keys(person) вертає новий масив можна скоротити даний запис:</p>
                        <p><code>
                            Object.keys(person).forEach( (key) => { <br>&nbsp
                                Тут пишем необхідний код <br>
                            })<br>
                        </code></p>                       
                    </div>
                    <div class="content_art">
                        <p class="sec_tit_txt_acord"> Контекст (Context) </p>
                        <p> Ключове слово <code>this</code></p>
                        <p> Приклад використання його в об'єкті:</p>
                        <p> <code>let person = { <br>
                            &nbsp;name:'Boris',<br>
                            &nbsp;age: 29,<br>
                            &nbsp;info(){<br>
                            &nbsp;console.log('Привіт , мене звати:', this.name)<br>&nbsp;}<br>
                            }
                        </code> 
                        </p>
                        <p>Ключове слово <code>this</code> в контексті об'єкту буде вказувати на назву об'єкту, що дозволяє звернутись до ключа не старим способом <code>person.name</code> а використовуючи більш універсальний спосіб <code>this.name</code></p>
                        <p>Присутні наступні методи:</p>
                        <ul>
                            <li class="list_style_accord"><code>bind()</code> При'вязує контекст який ми обираємо самостійно, він повертає нову функцію, тому при використанні його потрібно присвоювати змінну.<br> Приклад використання: <br> 
                                <code>
                                let logger = {<br>&nbsp;
                                    keysLog(){<br>&nbsp;&nbsp;
                                        Object.keys(this).forEach( key => {<br>&nbsp;&nbsp;&nbsp;
                                            console.log(` ${key} : ${this[key]}`)<br>&nbsp;&nbsp;
                                        })<br>&nbsp;
                                    }<br>
                                }<br>
                                let bound = logger.keysLog.bind(назва об'єкту)<br>
                                bound()<br>
                                </code>
                                В даному випадку <code>bound</code> вже являється функцією. Так як метод <code>bind</code> повертає функцію. Таким чином можна буде викликати її коли буде необхідно
                            </li>
                            <li class="list_style_accord"><code>call()</code> Подібний до методу <code>bind()</code> але він виконує свою дію, та одразу її викликає. Приклад використання: <br>
                                <code>
                                    let logger = {<br>&nbsp;
                                        keysLog(){<br>&nbsp;&nbsp;
                                            Object.keys(this).forEach( key => {<br>&nbsp;&nbsp;&nbsp;
                                                console.log(` ${key} : ${this[key]}`)<br>&nbsp;&nbsp;
                                            })<br>&nbsp;
                                        }<br>
                                    }<br>
                                    logger.keysLog.call(назва об'єкту)<br>
                                </code>
                            </li>
                        </ul>
                    </div>

                  </article>
                </div>
            </div>
            <!-- Асинхронність -->
            <div class="accordion-item">
                <h2 class="accordion-header" id="flush-headingSeven">
                  <button class="accordion-button collapsed btn_accord_style" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseSeven" aria-expanded="false" aria-controls="flush-collapseSeven">
                    <p class="header_name_item_stl">Асинхронність</p>
                  </button>
                </h2>
                <div id="flush-collapseSeven" class="accordion-collapse collapse" aria-labelledby="flush-headingSeven" data-bs-parent="#accordionFlushExample">
                  <article class="accordion-body">
                    <div class="content_art">
                        <p class="sec_tit_txt_acord"> Основи </p>
                        <p>Методи планування:</p>
                        <ul>
                            <li class="list_style_accord"><code>setIntervar( func|code , interval )</code> Буде виконано певну функцію чи код кожний інтервал часу. <br> Приклад: <br>
                                <code>
                                let interval = setInterval( () => {<br>&nbsp;
                                    console.log('Hellow')<br>
                                }, 1000)</code><br>
                                В даному випадку дана функція буде спрацьовувати кожну секунду<br><br>
                                Очищення <code> clearInterval(змінна якій присвоїна функція interval)</code>. Якщо застосоване очищення, тоді не буде здійснене виконання
                            </li>
                            <li class="list_style_accord"><code>setTimeout( func|code , timer )</code> Буде виконано певну функцію чи код по заввершенні часу <br> Приклад: <br>
                                <code>
                                let timeout = setTimeout( () => {<br>&nbsp;
                                    console.log('Hellow')<br>
                                },3000)</code><br>
                                В даному випадку дана функція буде спрацьована по завершенню 3-ох секунд<br><br>
                                Очищення <code> clearTimeout(змінна якій присвоїна функція timeout)</code>. Якщо застосоване очищення, тоді не буде здійснене виконання
                            </li>
                        </ul>
                    </div>

                  </article>
                </div>
            </div>
            <!-- Робота з DOM -->
            <div class="accordion-item">
                <h2 class="accordion-header" id="flush-headingEight">
                  <button class="accordion-button collapsed btn_accord_style" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseEight" aria-expanded="false" aria-controls="flush-collapseEight">
                    <p class="header_name_item_stl">Робота з DOM</p>
                  </button>
                </h2>
                <div id="flush-collapseEight" class="accordion-collapse collapse" aria-labelledby="flush-headingEight" data-bs-parent="#accordionFlushExample">
                  <article class="accordion-body">
                    <div class="content_art">
                        <p class="sec_tit_txt_acord"> Методи </p>
                        <ul>
                            <li class="list_style_accord"><code>let someElement = document.getElementById('назва ІД')</code> Повертає посилання до елементу якого ми звертаємся за ID</li>
                            <li class="list_style_accord"><code>let someElements = document.getElementsByTagName('тег')</code> Пошук елементу за HTML тегом , та повертає його посилання. <code> ЗВЕРНІТЬ УВАГУ!!!</code> Якщо ми отримуємо багато елементів одного типу, вони повертаються масивом. Що означає якщо необхідно до них щось примінити необхідно його перебрати, для прикладу через <code> forof</code><code class="comment_code"> // Застаріло</code></li>
                            <li class="list_style_accord"><code>let someElements = document.getElementsByClassName('назва класу')</code> Пошук елементу за класом <code class="comment_code"> // Застаріло</code> </li>
                            <li class="list_style_accord"><code>let someElement = document.querySelector('.class')</code> Пошук елементу за CSS серектором. Можна по класу (querySelector('.class')), по id (querySelector('#class')),по тегу (querySelector('h2'))</li>
                            <li class="list_style_accord"><code>let someElements = document.querySelectorAll('.class')</code>Пошук елементу за CSS серектором. Шукає всі елементи класу/тегу/id </li>
                        </ul>
                    </div>
                    <div class="content_art">
                        <p class="sec_tit_txt_acord"> Властивості </p>
                        <p>Кожен з DOM елементів має свої властивості, які можна використовувати при роботі з елементом. Для цього необхідно знайти елемент та присвоїти змінній, після чого можна використовувати ці властивості відповідно до змінної.<br> Приклад: <br> <code>let textElem = document.getElementById('some_element')<br>textElem.textContent = 'New text of this element'</code></p>
                        <ul>
                            <li class="list_style_accord"><code>змінна.textContent = 'новий текст'</code> Змінює текст в елементі</li>
                            <li class="list_style_accord"><code>змінна.style.color = 'колір' (різні формати: red , #654111)</code> Зміна кольору. <br> Таким чином, використовуючи властивість <code>.style</code> можна використовувати любу допустиму для JS властивість CSS. Головне якщо в CSS властивість шрифту задається використовуючи " - " font-size, то в JS ці властивості пишуться camelСase, тобто тоді буде fontSize </li>
                            <li class="list_style_accord"><code></code></li>
                            <li class="list_style_accord"><code></code></li>
                            <li class="list_style_accord"><code></code></li>
                        </ul>
                    </div>


                  </article>
                </div>
            </div>
            <!-- Приклад розділу стилізованого -->
            <!-- <div class="accordion-item">
                <h2 class="accordion-header" id="flush-headingThree">
                  <button class="accordion-button collapsed btn_accord_style" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseThree" aria-expanded="false" aria-controls="flush-collapseThree">
                    <p class="header_name_item_stl">Числа + BigInt</p>
                  </button>
                </h2>
                <div id="flush-collapseThree" class="accordion-collapse collapse" aria-labelledby="flush-headingThree" data-bs-parent="#accordionFlushExample">
                  <article class="accordion-body">
                    <div class="content_art">
                        <p class="sec_tit_txt_acord"> Змінні </p>
                        <p>Всі змінні бажано вказувати в стилі "camelCase" (приклад: <code> let firstName = 'Ivan' </code>)</p>
                        <ul>
                            <li class="list_style_accord"> <code>var year = 2022</code> - Оголошення змінної з можливісттю подальшого її перезапису (метод оголошення застарівший)</li>
                            <li class="list_style_accord"> <code>const myCountry = 'Ukraine'</code> - Змінні такого типу присутні лише для читання, перезапис даної змінної недоступний (бажано використовувати якщо змінна являється незмінною)</li>
                            <li class="list_style_accord"> <code>let centry = 21 </code> - Актуальна форма оголошення змінної, доступна для перезапису</li>
                        </ul>
                    </div>

                  </article>
                </div>
            </div> -->

    </body>
</html>